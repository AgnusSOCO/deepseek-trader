"""
Base Strategy Class

Abstract base class that all trading strategies must implement.
Provides a consistent interface for strategy development and execution.
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, Any, Optional, List
import pandas as pd


class SignalAction(Enum):
    """Trading signal actions"""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"
    CLOSE_LONG = "CLOSE_LONG"
    CLOSE_SHORT = "CLOSE_SHORT"


@dataclass
class TradingSignal:
    """
    Trading signal generated by a strategy
    
    Attributes:
        action: The trading action to take (BUY/SELL/HOLD)
        confidence: Confidence level (0.0 to 1.0)
        symbol: Trading pair symbol
        timestamp: When the signal was generated
        metadata: Additional information about the signal
        price: Current price when signal was generated
        stop_loss: Suggested stop-loss price (optional)
        take_profit: Suggested take-profit price (optional)
        position_size: Suggested position size as percentage of capital (optional)
    """
    action: SignalAction
    confidence: float
    symbol: str
    timestamp: datetime
    metadata: Dict[str, Any]
    price: float
    stop_loss: Optional[float] = None
    take_profit: Optional[float] = None
    position_size: Optional[float] = None
    
    def __post_init__(self):
        """Validate signal data"""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0.0 and 1.0, got {self.confidence}")
        if self.price <= 0:
            raise ValueError(f"Price must be positive, got {self.price}")
        if self.position_size is not None and self.position_size > 0 and not 0.0 < self.position_size <= 1.0:
            raise ValueError(f"Position size must be between 0.0 and 1.0, got {self.position_size}")


class BaseStrategy(ABC):
    """
    Abstract base class for all trading strategies
    
    All strategies must implement:
    - initialize(): Setup strategy parameters
    - on_data(): Process new market data
    - generate_signal(): Generate trading signals
    - get_parameters(): Return strategy configuration
    """
    
    def __init__(self, name: str, config: Dict[str, Any]):
        """
        Initialize strategy
        
        Args:
            name: Strategy name
            config: Strategy configuration parameters
        """
        self.name = name
        self.config = config
        self.is_initialized = False
        self.last_signal: Optional[TradingSignal] = None
        self.signal_history: List[TradingSignal] = []
        
        self.last_trade_time: Optional[datetime] = None
        self.daily_trade_count: int = 0
        self.last_trade_date: Optional[datetime] = None
        
        self.min_minutes_between_trades = config.get('min_minutes_between_trades', 0)
        self.max_daily_trades = config.get('max_daily_trades', 999)
        
    @abstractmethod
    def initialize(self) -> None:
        """
        Initialize strategy parameters and state
        
        Called once before strategy starts processing data.
        Use this to set up indicators, load models, etc.
        """
        pass
    
    @abstractmethod
    def on_data(self, market_data: Dict[str, Any], indicators: Dict[str, Any]) -> None:
        """
        Process new market data
        
        Called whenever new market data is available.
        Update internal state, calculate indicators, etc.
        
        Args:
            market_data: Current market data (price, volume, etc.)
            indicators: Pre-calculated technical indicators
        """
        pass
    
    @abstractmethod
    def generate_signal(self, 
                       market_data: Dict[str, Any], 
                       indicators: Dict[str, Any],
                       current_position: Optional[Dict[str, Any]] = None) -> TradingSignal:
        """
        Generate trading signal based on current market conditions
        
        Args:
            market_data: Current market data
            indicators: Technical indicators
            current_position: Current open position (if any)
            
        Returns:
            TradingSignal with action, confidence, and metadata
        """
        pass
    
    @abstractmethod
    def get_parameters(self) -> Dict[str, Any]:
        """
        Get strategy parameters
        
        Returns:
            Dictionary of strategy parameters and their current values
        """
        pass
    
    def update_parameters(self, params: Dict[str, Any]) -> None:
        """
        Update strategy parameters
        
        Args:
            params: New parameter values
        """
        self.config.update(params)
    
    def can_trade(self, current_time: datetime) -> tuple[bool, str]:
        """
        Check if strategy can trade based on cooldown and daily limits
        
        Args:
            current_time: Current timestamp
            
        Returns:
            Tuple of (can_trade, reason)
        """
        if self.last_trade_date and current_time.date() != self.last_trade_date.date():
            self.daily_trade_count = 0
            self.last_trade_date = current_time
        
        if self.daily_trade_count >= self.max_daily_trades:
            return False, f"Daily trade limit reached ({self.daily_trade_count}/{self.max_daily_trades})"
        
        if self.last_trade_time and self.min_minutes_between_trades > 0:
            minutes_since_last = (current_time - self.last_trade_time).total_seconds() / 60
            if minutes_since_last < self.min_minutes_between_trades:
                return False, f"Cooldown active ({minutes_since_last:.1f}/{self.min_minutes_between_trades} min)"
        
        return True, "OK"
    
    def record_signal(self, signal: TradingSignal) -> None:
        """
        Record a generated signal
        
        Args:
            signal: Trading signal to record
        """
        self.last_signal = signal
        self.signal_history.append(signal)
        
        if signal.action in [SignalAction.BUY, SignalAction.SELL]:
            self.last_trade_time = signal.timestamp
            if not self.last_trade_date or signal.timestamp.date() != self.last_trade_date.date():
                self.daily_trade_count = 1
                self.last_trade_date = signal.timestamp
            else:
                self.daily_trade_count += 1
        
        if len(self.signal_history) > 1000:
            self.signal_history = self.signal_history[-1000:]
    
    def get_signal_history(self, limit: int = 100) -> List[TradingSignal]:
        """
        Get recent signal history
        
        Args:
            limit: Maximum number of signals to return
            
        Returns:
            List of recent trading signals
        """
        return self.signal_history[-limit:]
    
    def reset(self) -> None:
        """Reset strategy state"""
        self.last_signal = None
        self.signal_history = []
        self.is_initialized = False
        self.last_trade_time = None
        self.daily_trade_count = 0
        self.last_trade_date = None
    
    def __repr__(self) -> str:
        return f"{self.__class__.__name__}(name='{self.name}', initialized={self.is_initialized})"
